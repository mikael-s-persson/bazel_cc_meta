import argparse
import json
import sys
import os
from pathlib import PurePath


def _includes_from_makefile(file_name):
    with open(file_name, "r") as file:
        md_includes_list_str = file.read()
    md_includes_list = md_includes_list_str.replace("\\\n", "").strip().split()
    if len(md_includes_list) < 2:
        print(
            "Makefile '{}' appears malformed. Aborting...".format(file_name),
            file=sys.stderr,
        )
        sys.exit(1)
    if len(md_includes_list) < 3:
        return md_includes_list[0], md_includes_list[1], []
    return md_includes_list[0], md_includes_list[1], [PurePath(os.path.normpath(p)) for p in md_includes_list[2:]]


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="IdentifyDirectIncludes",
        description="Identify direct includes from a json dictionary of include dirs, a dump of all direct includes, and a dump of all includes.",
    )
    parser.add_argument("incl_dirs_file")
    parser.add_argument("direct_incl_makefile")
    parser.add_argument("all_incl_makefile")
    parser.add_argument("output_file")
    args = parser.parse_args()

    incl_dirs = {}
    with open(args.incl_dirs_file, "r") as f:
        incl_dirs = json.load(f)

    if (("include_dirs" not in incl_dirs) or ("iquote_dirs" not in incl_dirs) or
        ("isystem_dirs" not in incl_dirs) or ("builtin_dirs" not in incl_dirs)):
        print(
            "Missing some lists of include dirs is '{}'! Got {}. Aborting...".format(args.incl_dirs_file, incl_dirs.keys()),
            file=sys.stderr,
        )
        sys.exit(1)

    incl_dirs_i = frozenset([PurePath(os.path.normpath(p)) for p in incl_dirs["include_dirs"]])
    incl_dirs_iquote = frozenset([PurePath(os.path.normpath(p)) for p in incl_dirs["iquote_dirs"]])
    incl_dirs_isystem = frozenset([PurePath(os.path.normpath(p)) for p in incl_dirs["isystem_dirs"]])
    incl_dirs_builtin = frozenset([PurePath(os.path.normpath(p)) for p in incl_dirs["builtin_dirs"]])

    dincl_obj_file, dincl_src_file, dincl_incl_list = _includes_from_makefile(args.direct_incl_makefile)
    aincl_obj_file, aincl_src_file, aincl_incl_list = _includes_from_makefile(args.all_incl_makefile)

    if dincl_obj_file != aincl_obj_file or dincl_src_file != aincl_src_file:
        print(
            "Object files or source files in makefiles do not match! In '{}' and '{}'. Aborting...".format(args.direct_incl_makefile, args.all_incl_makefile),
            file=sys.stderr,
        )
        sys.exit(1)

    # The objective of this tool is to take the direct-includes list (dincl_incl_list) and filter
    # out includes that are expected to come from system directories (e.g., <string> or <netinet/ip.h>)
    # and those that should come from explicitly listed dependencies in the cc_* target.
    # This is easier said than done.
    #
    # The direct includes list is generated by removing all include directories (not passing the
    # -I/-iquote/-isystem paths, and with --no-standard-includes / -nostdinc++) to get the
    # compiler to simply dump a list of all directly included headers (with, at least, shallow
    # pre-processing logic). Then, we figure out which includes would have been found in an
    # include path before the built-in ones.
    #
    # The all-includes list (aincl_incl_list) is also dumped from the compiler, but with all include
    # paths provided. Unfortunately, this is a full recursive list and the order is not stable
    # or fully deterministic (i.e., options like '-H' cannot be used to reliably identify direct
    # includes). But, we can use it to figure out where the compiler found the direct includes
    # that were dumped (and not found) on the previous pass.
    #
    # So, we take a direct include, search for it (ends with) in the all-includes list, take the
    # other part of that path and try to find it in one of the include dir lists. If the directory
    # that contains that included file is not part of the built-in directories (or the same
    # directory as the input/source file), then it's coming from a Bazel target that should
    # be part of the direct 'deps' attribute. Similarly, if we cannot find it at all (i.e.,
    # the source does not actually compile right now), then we expect a bazel target should
    # provide it.
    #
    # N.B.: A pre-condition for this to work is that the built-in directories (e.g., /usr/include)
    #       is not being used (by accident) to find headers that the user is intending to
    #       obtain from a Bazel target (e.g., the host system has 'libabsl-dev' installed, and
    #       the Bazel module imports 'abseil-cpp' at a specific version, intending to use that
    #       dependency, but the user forgets to do so on a particular cc_* target, in that case,
    #       the compiler will still find the headers in the built-in '/usr/include' directory).
    #       The above technique only works if that is not a pre-existing problem with the current
    #       build configuration (e.g., if the 'libabsl-dev' example above applies, then this tool
    #       will also classify the abseil headers as system / built-in headers, so we cannot fix
    #       or detect that problem in a general way).
    #
    # For reference, the GCC / Clang standard inclusion ordering between the different
    # arguments is the following:
    # 1. For the quote form of the include directive, the directory of the current file is searched first.
    # 2. For the quote form of the include directive, the directories specified by -iquote options are searched in left-to-right order, as they appear on the command line.
    # 3. Directories specified with -I options are scanned in left-to-right order.
    # 4. Directories specified with -isystem options are scanned in left-to-right order.
    # 5. Standard system directories are scanned.

    dep_incl_list = []
    sys_incl_list = []
    for dincl_path in dincl_incl_list:
        dincl_dirs = []
        for aincl_path in aincl_incl_list:
            if aincl_path.match(str(dincl_path)):
                dincl_dirs.append(PurePath(*aincl_path.parts[:-len(dincl_path.parts)]))
        found_in_dep = False
        found_in_sys = False
        for dincl_dir in dincl_dirs:
            if ((dincl_dir in incl_dirs_i) or (dincl_dir in incl_dirs_iquote) or
                (dincl_dir in incl_dirs_isystem)):
                found_in_dep = True
            elif ((dincl_dir in incl_dirs_builtin) or (dincl_dir.match("*-*-*") and dincl_dir.parent in incl_dirs_builtin) or (PurePath(dincl_src_file).parent == dincl_dir)):
                found_in_sys = True

        if found_in_dep or not found_in_sys:
            # Found in explicit include paths (maybe also in built-in) or not at all.
            dep_incl_list.append(str(dincl_path))
        else:
            # Found only in built-in directories.
            sys_incl_list.append(str(dincl_path))

    with open(args.output_file, "w") as out_file:
        json.dump(
            {
                "source_file": dincl_src_file,
                "dep_imports": dep_incl_list,
                "sys_imports": sys_incl_list,
            },
            out_file,
            indent=2,
        )


